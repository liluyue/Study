从目的来看：
－创建型模式（Creational）：负责对象创建。
－结构型模式（Structural）：处理类与对象间的组合。
－行为型模式（Behavioral）：类与对象交互中的职责分配。

程序设计必须遵循的六大原则：
1.单一职责（Single Responsibility Principle）
2.开闭原则（Open Close Principle）
3.依赖倒置原则（）
4.接口隔离原则（）
5.迪米特原则（）
6.里氏替换原则（）


软件以稳定为第一要义，故开闭原则为首要原则。要最大化的遵从开闭原则，软件的原始设计的全面性至为重要，故此时需最大化遵循依赖倒置原则、接口隔离原则、迪米特原则。软件功能的实现及修复则大多借助于里氏替换原则。

创建型：
1.单利模式（Singleton）：
优点：节约资源。
注意：应尽量遵从单一职责原则、接口隔离原则，以及避免过量的同步。否则将造成处理阻塞。
2.构造者模式（Builder）：
优点：将对象需要一次性配置的内容的设置与对象抽离，使对象仅仅持有需要动态改变的属性。增加了对象初始化配置的灵活性和阅读对象的便易。
3.原型模式（）
优点：保护数据、节约创建时间。
4.抽象工厂（）
遵从：依赖倒置原则、接口隔离原则、迪米特原则、里氏替换原则
 
结构型：
Adapter：将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
Bridge：将抽象部分与它的实现部分分离，使得它们都可以独立地变化。
Composite：将对象组合成树型结构以表示“部分-整体”的层次结构。Composite使得客户端代码对单个对象和组合对象的使用具有一致性。
Decorator：动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类方式更为灵活。
Facade：为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更容易使用。
FlyWeight：运用共享技术有效地支持大量细粒度的对象。
Proxy：为其他对象提供一个代理以控制对这个对象的访问。


行为型：
Chain of
Responsibility：将请求的发送者和接收者构成一个链条，请求沿着链条传递，从而使多个对象都有机会处理这个请求。
Command：将请求封装为一个对象，从而使请求参数化以支持请求排队或记录请求日志，并在必要时取消这个请求。
Interpreter：定义一个简单语言的语法，并建立一个具有树形结构的语法解释器来解释语言中的句子。
Mediator：用一个中介对象来封装一系列对象的交互。中介者使各对象不需要显示地相互引用，从而将分散的对象通信进行集中统一控制，同时解除了各对象之间的直接耦合关系。
Memento：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样在必要时就可恢复对象的历史状态。
Observer：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。
State：允许一个对象在不做任何修改的前提下增加其内部状态和对应状态的行为。
Strategy：定义一系列算法，把它们一个个封装起来，并使它们可相互替换，从而使得算法的变化可独立于使用它的客户端代码。
TemplateMethod：定义一个操作算法的骨架，而将一些步骤延迟到子类中。TemplateMethod使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
Visitor：用统一的接口变换角度地去访问一个集合结构类中的各个组成元素。

