1.使用DialogFragment来将dialog的生命周期与activity的生命周期绑定
2.DialogFragment的透明：
1）在onCreateView中：
  Window window = getDialog().getWindow();
          if (window!=null) {
	              window.setGravity(Gravity.FILL);
		                  window.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
				    }
2）在onStart中：
   Window window = getDialog().getWindow();
           if (window!=null) {
	               WindowManager.LayoutParams windowParams = window.getAttributes();
		                   windowParams.dimAmount = 0.0f;
				               window.setAttributes(windowParams);
					               }
3.集合的同步：
Collections.synchronizedList(); 用listIterator时要加锁（访问引用的内容!=访问引用所在的对象OB）
CopyOnWriteArrayList:读写分离

4.synchronized :本质是针对代码块的锁，钥匙是同步的关键字
5.不同状态下文字颜色设置：
ColorStateList
ColorStateList.createFromXml
resource.getColorStateList
6.Fragment实现懒加载：setUserVisibleHint

7.触屏事件
dispatchTouchEvent ->onInterceptTouchEvent -> (setOnTouchListener ->onTouchEvent)
dispatchTouchEvent 内部调用了onInterceptTouchEvent 、setOnTouchListener、onTouchEvent
当onInterceptTouchEvent拦截事件后当次其子view收到MotionEvent为null，后续接收不到事件，
当次onTouchEvent 不走，后续onInterceptTouchEvent 不再走，走onTouchEvent
如果onInterceptTouchEvent在ACTION_DOWN时拦截则当次onTouchEvent走，以后该view接收不到事件
if(setOnTouchListener) else if(onTouchEvent)
猜测：
只有流程中存在onTouchEvent=true，该流程才有机会接收到后续事件
且后续事件的终点都是onTouchEvent=true所在的view（设该view记end标志），
当上游onInterceptTouchEvent=true（parent）时，end标志转到parent身上，存在end标志的view的
onInterceptTouchEvent将不再执行
一旦end标志存在，无论后续是否是false，该流程都会走

8.layout inspector 的使用
需要开启debug模式 ：android:debuggable="true"

